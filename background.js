/**
 * background.js (Service Worker)
 * Handles background tasks for the Selenium Recorder extension.
 * - Manages recording state.
 * - Listens for messages from popup, content script, and side panel.
 * - Generates the Selenium script (handling CSS/XPath, JS click fallback, screenshots).
 * - Creates and downloads the ZIP archive.
 * *** Assumes side panel is opened by the popup script. ***
 * *** Allows recording to continue across same-tab navigations/reloads. ***
 * *** Handles cancellation request from side panel. ***
 * *** Handles delete action request from side panel. ***
 */

// --- Load required scripts ---
try {
    // Load JSZip library globally when the service worker starts
    importScripts('jszip.min.js');
    console.log("Background: JSZip library loaded successfully via importScripts.");
} catch (e) {
    console.error("Background: CRITICAL ERROR - Failed to load JSZip library.", e);
}


// --- State Variables ---
let isRecording = false;
let recordedActions = []; // Actions now include selectorType ('CSS' or 'XPath')
let capturedHTMLs = []; // Array to store captured HTML strings
let startURL = ''; // Still store the initial URL, might be useful
let recordingTabId = null;

// --- Helper Functions ---
// generateSeleniumScript, repr, resetRecordingState functions remain the same...

/**
 * Generates the Python Selenium script content.
 * - Handles CSS and XPath selectors.
 * - Adds JS click fallback.
 * - Adds screenshot command after each step.
 * - Uses 3-second pause between steps.
 * - Fixes stepCounter NameError in exception blocks.
 * - Logs exception type in final catch block.
 * - Simplifies successful action screenshot filename.
 * - Ignores HTML_Capture actions.
 * @returns {string} The generated Python script.
 */
function generateSeleniumScript() {
    let scriptLines = [
        `# Generated by Selenium Recorder Chrome Extension`,
        `# WARNING: This script executes actions sequentially starting from the initial URL.`,
        `# It does not automatically handle page navigations that occurred during recording.`,
        `# Selectors might be CSS or Absolute XPath (if CSS failed). XPath is brittle.`,
        `import time`,
        `import os # Needed for creating screenshots directory`,
        `from selenium import webdriver`,
        `from selenium.webdriver.common.by import By`,
        `from selenium.webdriver.support.ui import Select`,
        `from selenium.webdriver.support.ui import WebDriverWait`,
        `from selenium.webdriver.support import expected_conditions as EC`,
        `from selenium.common.exceptions import NoSuchElementException, TimeoutException, ElementClickInterceptedException`,
        ``,
        `# --- Screenshot Setup ---`,
        `SCREENSHOT_DIR = "selenium_screenshots"`,
        `if not os.path.exists(SCREENSHOT_DIR):`,
        `    os.makedirs(SCREENSHOT_DIR)`,
        ``,
        `# --- WebDriver Setup ---`,
        `driver = webdriver.Chrome()`,
        `driver.maximize_window()`,
        `wait = WebDriverWait(driver, 10)`,
        ``,
        `try:`,
        `    # 1. Navigate to Start URL`,
        `    print(f'Navigating to initial URL: ${startURL}')`,
        `    driver.get('${startURL}')`,
        "    time.sleep(3)",
        `    screenshot_path = os.path.join(SCREENSHOT_DIR, f'screenshot_step_1_navigated.png')`,
        `    driver.save_screenshot(screenshot_path)`,
        `    print(f'  Screenshot saved: {screenshot_path}')`,
        ``
    ];

    let scriptStepCounter = 2; // Renamed to avoid confusion with action.step

    const scriptableActions = recordedActions.filter(action => action.type !== 'HTML_Capture');

    scriptableActions.forEach((action, index) => {
        let selector = action.selector;
        let byType = '';
        let selectorValue = '';
        let byTypeString = ''; // Store the By.TYPE string representation

        // Determine selector type (CSS or XPath)
        if (action.selectorType === 'XPath') { // Check stored type first
            byTypeString = 'By.XPATH';
            selectorValue = selector.substring(6);
            scriptLines.push(`    # Step ${scriptStepCounter}: ${action.type} on element with XPATH selector`);
        } else { // Default to CSS or determine specific CSS type
            selectorValue = selector;
            byTypeString = selector.startsWith('#') ? 'By.ID' :
                           selector.includes('[name="') ? 'By.CSS_SELECTOR' :
                           selector.startsWith('.') ? 'By.CSS_SELECTOR' :
                           selector.match(/^[a-zA-Z]+$/) ? 'By.TAG_NAME' :
                           'By.CSS_SELECTOR';

            if (byTypeString === 'By.ID') {
                selectorValue = selector.substring(1);
            }
            scriptLines.push(`    # Step ${scriptStepCounter}: ${action.type} on element with CSS selector '${selector}'`);
        }

        // Define Python variable for current step
        scriptLines.push(`    current_script_step = ${scriptStepCounter}`); // Use script step counter
        // Assign Python variables for selector and type
        scriptLines.push(`    py_selector_value = ${repr(selectorValue)}`);
        scriptLines.push(`    py_by_type = ${byTypeString}`);

        // Add wait and action block
        scriptLines.push(`    print(f'Step {current_script_step}: Waiting for element ({py_by_type}, {py_selector_value})')`);
        scriptLines.push(`    try:`);
        scriptLines.push(`        element = wait.until(EC.presence_of_element_located((py_by_type, py_selector_value)))`);
        if (action.type === 'Click' || action.type === 'Select') {
             scriptLines.push(`        element = wait.until(EC.element_to_be_clickable((py_by_type, py_selector_value)))`);
        }
        scriptLines.push(`        print(f'Step {current_script_step}: Found element. Performing action: ${action.type}')`);

        switch (action.type) {
            case 'Click':
                scriptLines.push(`        try:`);
                scriptLines.push(`            element.click()`);
                scriptLines.push(`        except ElementClickInterceptedException:`);
                scriptLines.push(`            print("  WARN: Element click intercepted, attempting JavaScript click.")`);
                scriptLines.push(`            driver.execute_script("arguments[0].click();", element)`);
                break;
            case 'Input':
                scriptLines.push(`        py_input_value = ${repr(action.value)}`);
                scriptLines.push(`        element.clear() # Optional: Clear field before typing`);
                scriptLines.push(`        element.send_keys(py_input_value)`);
                break;
            case 'Select':
                scriptLines.push(`        py_select_value = ${repr(action.value)}`);
                scriptLines.push(`        select = Select(element)`);
                scriptLines.push(`        select.select_by_value(py_select_value) # Assumes selection by value`);
                break;
        }
        // Add Screenshot Command
        scriptLines.push(`        screenshot_path = os.path.join(SCREENSHOT_DIR, f'screenshot_step_{current_script_step}_after_action.png')`);
        scriptLines.push(`        driver.save_screenshot(screenshot_path)`);
        scriptLines.push(`        print(f'  Screenshot saved: {screenshot_path}')`);

        scriptLines.push(`    except TimeoutException:`);
        scriptLines.push(`        print(f'Error in Step {current_script_step}: Element not found or timed out. Selector: ({py_by_type}, {py_selector_value})')`);
        scriptLines.push(`        screenshot_path = os.path.join(SCREENSHOT_DIR, f'screenshot_step_{current_script_step}_error_timeout.png')`); // Screenshot on error
        scriptLines.push(`        driver.save_screenshot(screenshot_path)`);
        scriptLines.push(`        print(f'  Error screenshot saved: {screenshot_path}')`);
        scriptLines.push(`        raise # Re-raise the exception to stop the script`);
        scriptLines.push(``); // End of outer try block

        scriptLines.push("    time.sleep(3) # Pause between steps");
        scriptLines.push(``);
        scriptStepCounter++; // Increment script step counter
    });

    scriptLines.push(`    print('Script finished successfully!')`)
    scriptLines.push(``)
    scriptLines.push(`except Exception as e:`)
    scriptLines.push(`    print(f'An unexpected error occurred outside specific steps: Type={type(e).__name__}, Message={str(e)}')`)
    scriptLines.push(`    # Screenshot on unexpected error`)
    scriptLines.push(`    try:`)
    scriptLines.push(`        screenshot_path = os.path.join(SCREENSHOT_DIR, f'screenshot_unexpected_error.png')`)
    scriptLines.push(`        driver.save_screenshot(screenshot_path)`)
    scriptLines.push(`        print(f'  Error screenshot saved: {screenshot_path}')`)
    scriptLines.push(`    except Exception as screen_err:`)
    scriptLines.push(`        print(f"  Could not save error screenshot: {str(screen_err)}")`)
    scriptLines.push(``)
    scriptLines.push(`finally:`)
    scriptLines.push(`    # --- Cleanup ---`)
    scriptLines.push(`    print('Closing WebDriver.')`)
    scriptLines.push(`    driver.quit()`)
    scriptLines.push(``)

    return scriptLines.join('\n');
}

/**
 * Helper function to mimic Python's repr() for safely embedding strings in the generated script.
 * Handles quotes and escape sequences.
 * @param {*} value - The value to represent.
 * @returns {string} A string representation suitable for embedding in Python code.
 */
function repr(value) {
    // Use JSON.stringify for robust escaping, suitable for Python strings
    return JSON.stringify(String(value));
}


/**
 * Resets the recording state and optionally disables the side panel.
 * @param {boolean} [disablePanel=false] - Whether to attempt to disable the side panel.
 */
function resetRecordingState(disablePanel = false) {
    const closingTabId = recordingTabId; // Store ID before resetting state variables
    isRecording = false;
    recordedActions = [];
    capturedHTMLs = [];
    startURL = '';
    recordingTabId = null;
    console.log("Background: Recording state reset.");

    // Update side panel UI if it's still open
    chrome.runtime.sendMessage({ command: "update_ui", data: { actions: [], isRecording: false, htmlCount: 0 } })
        .catch(e => console.log("Background: Side panel likely closed during reset (expected)."));

    // Optionally disable the side panel for the tab
    if (disablePanel && closingTabId) {
        console.log(`Background: Attempting to disable side panel for tab ${closingTabId}.`);
        chrome.tabs.get(closingTabId, (tab) => { // Check if tab still exists
            if (!chrome.runtime.lastError && tab) {
                chrome.sidePanel.setOptions({ tabId: closingTabId, enabled: false })
                    .then(() => console.log(`Background: Side panel disabled for tab ${closingTabId}.`))
                    .catch(e => console.warn(`Background: Failed to disable side panel for tab ${closingTabId}:`, e));
            } else {
                 console.log(`Background: Tab ${closingTabId} not found or error checking tab, skipping side panel disable.`);
            }
        });
    }
}

// --- Event Listeners ---

chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
    console.log("Background received message:", message.command, "from", sender.tab ? "tab " + sender.tab.id : "extension");

    switch (message.command) {
        case "start_recording":
            if (isRecording) {
                console.warn("Background: Recording already in progress.");
                sendResponse({ success: false, message: "Recording already active." });
                return true;
            }

            const { tabId, url } = message.data || {};
            if (!tabId || !url) {
                 console.error("Background: Missing tabId or url in start_recording message.");
                 sendResponse({ success: false, message: "Missing data from popup." });
                 return true;
            }

            resetRecordingState(false); // Reset state without disabling panel yet

            recordingTabId = tabId;
            startURL = url;
            isRecording = true;

            console.log(`Background: Starting recording state for tab ${recordingTabId} with URL: ${startURL}`);

            chrome.scripting.executeScript({
                target: { tabId: recordingTabId },
                files: ['content.js']
            })
            .then(() => {
                console.log("Background: Content script injected.");
                return new Promise(resolve => setTimeout(resolve, 250));
            })
            .then(() => {
                 console.log("Background: Sending initial UI update to side panel.");
                return chrome.runtime.sendMessage({
                    command: "update_ui",
                    data: { actions: recordedActions, isRecording: true, startUrl: startURL, htmlCount: capturedHTMLs.length }
                });
            })
            .then(() => {
                console.log("Background: Initial UI update sent successfully.");
                sendResponse({ success: true });
            })
            .catch(error => {
                console.error("Background: Error during recording start sequence (post-panel open):", error);
                resetRecordingState(true); // Clean up fully on error, disable panel
                sendResponse({ success: false, message: `Failed to start recording logic: ${error.message}` });
            });

            return true;

        case "record_action":
            if (!isRecording || !recordingTabId || (sender.tab && sender.tab.id !== recordingTabId)) {
                return true;
            }
            const action = message.data;
            action.step = recordedActions.length + 1; // Assign step based on current array length

            // Determine and store selector type
            if (action.selector && action.selector.startsWith('xpath=')) {
                action.selectorType = 'XPath';
            } else {
                action.selectorType = 'CSS'; // Default to CSS
            }

            if (!action.selector) {
                 console.warn("Background: Action received without selector:", action);
                 action.selector = "SELECTOR_MISSING";
                 action.selectorType = 'N/A';
            }
            delete action.elementInfo;

            console.log("Background: Recording action:", action);
            recordedActions.push(action);

            chrome.runtime.sendMessage({ command: "update_ui", data: { actions: recordedActions, isRecording: true, htmlCount: capturedHTMLs.length } })
                .catch(e => console.warn("Background: Side panel not available for action update:", e));

            sendResponse({ success: true });
            return true;

        case "capture_html":
             if (!isRecording || !recordingTabId) {
                sendResponse({ success: false, message: "Not recording." });
                return true;
             }
             try {
                 chrome.tabs.sendMessage(recordingTabId, { command: "get_html" }, (response) => {
                     if (chrome.runtime.lastError) {
                         console.error("Background: Error requesting HTML from content script:", chrome.runtime.lastError.message);
                         sendResponse({ success: false, message: chrome.runtime.lastError.message });
                     } else if (response && response.success && typeof response.html === 'string') {
                         capturedHTMLs.push(response.html);
                         console.log(`Background: HTML captured (${capturedHTMLs.length} total). Size: ${response.html.length}`);

                         const captureAction = {
                             type: 'HTML_Capture',
                             step: recordedActions.length + 1, // Assign step based on current length
                             timestamp: Date.now(),
                             selectorType: 'N/A'
                         };
                         recordedActions.push(captureAction);
                         console.log("Background: Recording action:", captureAction);

                         chrome.runtime.sendMessage({
                             command: "update_ui",
                             data: {
                                 actions: recordedActions,
                                 htmlCount: capturedHTMLs.length,
                                 isRecording: true
                             }
                          })
                             .catch(e => console.warn("Background: Side panel not available for HTML count update:", e));

                         sendResponse({ success: true, count: capturedHTMLs.length });
                     } else {
                         console.error("Background: Failed to get valid HTML from content script.", response);
                         sendResponse({ success: false, message: "Failed to get valid HTML." });
                     }
                 });
             } catch (error) {
                  console.error("Background: Error sending get_html message:", error);
                  sendResponse({ success: false, message: `Error contacting content script: ${error.message}` });
             }
             return true;

        // *** Add handler for delete request ***
        case "delete_action":
             if (!isRecording) {
                sendResponse({ success: false, message: "Not recording." });
                return true;
             }
             const stepToDelete = message.data?.step;
             if (typeof stepToDelete !== 'number') {
                 console.error("Background: Invalid step number received for deletion.");
                 sendResponse({ success: false, message: "Invalid step number." });
                 return true;
             }

             console.log(`Background: Attempting to delete action at step ${stepToDelete}`);

             // Find the index of the action with the matching step number
             const indexToDelete = recordedActions.findIndex(action => action.step === stepToDelete);

             if (indexToDelete === -1) {
                 console.warn(`Background: Action with step ${stepToDelete} not found.`);
                 sendResponse({ success: false, message: "Step not found." });
                 return true;
             }

             // Remove the action
             const deletedAction = recordedActions.splice(indexToDelete, 1)[0];
             console.log("Background: Deleted action:", deletedAction);

             // If the deleted action was an HTML capture, also remove the corresponding HTML data
             if (deletedAction.type === 'HTML_Capture') {
                 // This assumes HTML captures are stored in order and match the action list.
                 // A more robust approach might involve linking captures to actions via IDs.
                 // For simplicity, we find the Nth HTML_Capture action and remove the Nth HTML blob.
                 let htmlCaptureIndex = -1;
                 let currentHtmlCaptureCount = 0;
                 for(let i = 0; i <= indexToDelete; i++) { // Count captures up to the deleted index
                     if (recordedActions[i]?.type === 'HTML_Capture' || i === indexToDelete) { // Also count the deleted one if it was a capture
                         currentHtmlCaptureCount++;
                     }
                 }
                 htmlCaptureIndex = currentHtmlCaptureCount - 1; // 0-based index

                 if (htmlCaptureIndex >= 0 && htmlCaptureIndex < capturedHTMLs.length) {
                     console.log(`Background: Removing associated HTML capture at index ${htmlCaptureIndex}`);
                     capturedHTMLs.splice(htmlCaptureIndex, 1);
                 } else {
                      console.warn(`Background: Could not find matching HTML capture data for deleted action step ${stepToDelete}`);
                 }
             }


             // Re-number subsequent steps
             for (let i = indexToDelete; i < recordedActions.length; i++) {
                 recordedActions[i].step = i + 1; // Steps are 1-based
             }
             console.log("Background: Renumbered subsequent steps.");


             // Send updated list back to side panel
             chrome.runtime.sendMessage({
                 command: "update_ui",
                 data: {
                     actions: recordedActions,
                     htmlCount: capturedHTMLs.length, // Send updated count
                     isRecording: true
                 }
              })
                 .catch(e => console.warn("Background: Side panel not available for delete update:", e));

             sendResponse({ success: true });
             return true;


        case "save_export":
            if (!isRecording) {
                sendResponse({ success: false, message: "Not recording." });
                return true;
            }
            console.log("Background: Save and Export triggered.");

            if (typeof JSZip === 'undefined') {
                 console.error("Background: JSZip is not defined. Export failed.");
                 sendResponse({ success: false, message: "JSZip library error (not loaded)." });
                 return true;
            }

            const seleniumScript = generateSeleniumScript();
            console.log("Background: Selenium script generated.");

            try {
                const zip = new JSZip();
                zip.file("selenium_script.py", seleniumScript);

                console.log(`Background: Preparing to zip ${capturedHTMLs.length} captured HTML file(s).`);
                console.log('Background: capturedHTMLs array content (lengths):', capturedHTMLs.map(h => h?.length ?? 'null'));

                capturedHTMLs.forEach((html, index) => {
                    const filename = `capture_${index + 1}.html`;
                    console.log(`Background: Adding file to zip: ${filename}, HTML size: ${html?.length ?? 'N/A'}`);
                    if (typeof html === 'string') {
                         zip.file(filename, html);
                    } else {
                         console.warn(`Background: Skipping invalid HTML data at index ${index}`);
                    }
                });

                console.log("Background: Generating ZIP blob...");
                zip.generateAsync({ type: "blob" })
                    .then(content => {
                        console.log(`Background: ZIP blob generated (size: ${content.size}). Converting to data URL...`);
                        const reader = new FileReader();
                        reader.onload = function() {
                            const dataUrl = reader.result;
                            const zipFilename = "selenium_recording.zip";
                            console.log(`Background: Blob converted to data URL (length: ${dataUrl.length}). Initiating download...`);

                            chrome.downloads.download({
                                url: dataUrl,
                                filename: zipFilename,
                                saveAs: true
                            }).then(downloadId => {
                                 if (downloadId) {
                                     console.log("Background: Download started with ID:", downloadId);
                                     sendResponse({ success: true });
                                     resetRecordingState(true); // Reset state and disable panel
                                 } else {
                                     console.error("Background: Download failed to initiate.");
                                     sendResponse({ success: false, message: "Download failed to initiate." });
                                     resetRecordingState(true);
                                 }
                            }).catch(err => {
                                 console.error("Background: Download failed:", err);
                                 sendResponse({ success: false, message: `Download failed: ${err.message}` });
                                 resetRecordingState(true);
                            });
                        };
                        reader.onerror = function() {
                            console.error("Background: FileReader failed to read blob.");
                            sendResponse({ success: false, message: "Failed to read generated ZIP data." });
                            resetRecordingState(true);
                        };
                        reader.readAsDataURL(content);
                    })
                    .catch(err => {
                        console.error("Background: Error generating ZIP blob:", err);
                        sendResponse({ success: false, message: `ZIP generation failed: ${err.message}` });
                        resetRecordingState(true);
                    });

            } catch (e) {
                console.error("Background: Error during ZIP creation/processing:", e);
                sendResponse({ success: false, message: `JSZip library error: ${e.message}` });
                resetRecordingState(true);
            }
            return true;

        case "cancel_recording":
            if (!isRecording) {
                sendResponse({ success: false, message: "Not recording." });
                return true;
            }
            console.log("Background: Cancel recording request received.");
            resetRecordingState(true); // Reset state and disable panel
            sendResponse({ success: true });
            return true;


        case "get_status":
            sendResponse({ isRecording: isRecording, recordingTabId: recordingTabId });
            return true;

        case "request_current_state":
             if (isRecording && sender.contextType === "SIDE_PANEL") {
                 console.log("Background: Side panel requested current state.");
                 sendResponse({
                     actions: recordedActions,
                     htmlCount: capturedHTMLs.length,
                     isRecording: true,
                     startUrl: startURL
                 });
             } else {
                 sendResponse(null);
             }
             return true;


        case "stop_recording_internal":
            if (isRecording && sender.contextType === "SIDE_PANEL") {
                 console.log("Background: Side panel closed or navigated away, stopping recording.");
                 resetRecordingState(false); // Reset state only
                 sendResponse({success: true});
            }
             else {
                 sendResponse({success: false, message: "Not recording or invalid context"});
             }
            return true;


        default:
             console.log("Background: Unhandled command:", message.command);
             sendResponse({ success: false, message: "Unknown command" });
             return false;
    }
});

// Tab listeners (onRemoved, onUpdated)
chrome.tabs.onRemoved.addListener((tabId, removeInfo) => {
    if (isRecording && tabId === recordingTabId) {
        console.log(`Background: Recorded tab (${tabId}) was closed. Stopping recording.`);
        resetRecordingState(false);
    }
});

chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {
    if (isRecording && tabId === recordingTabId) {
        if (changeInfo.url) {
             console.log(`Background: Recorded tab (${tabId}) navigated to ${changeInfo.url}. Recording continues.`);
        }
        if (changeInfo.status) {
             console.log(`Background: Recorded tab (${tabId}) status changed to ${changeInfo.status}. Recording continues.`);
        }
    }
});


console.log("Background service worker started.");
