/**
 * background.js (Service Worker)
 * Handles background tasks for the Selenium Recorder extension.
 * - Manages recording state across main tab and popups within a WINDOW.
 * - Listens for messages from popup, content script, and side panel.
 * - Generates the Selenium script.
 * - Creates and downloads the ZIP archive.
 * *** Side panel is opened globally for the window. ***
 * *** Allows recording to continue across same-tab navigations/reloads. ***
 * *** Handles cancellation, delete, and pause requests from side panel. ***
 * *** Detects popups/new tabs AND manual tab activations within the recorded window. ***
 */

// --- Load required scripts ---
try {
    importScripts('jszip.min.js');
    console.log("Background: JSZip library loaded successfully via importScripts.");
} catch (e) {
    console.error("Background: CRITICAL ERROR - Failed to load JSZip library.", e);
}


// --- State Variables ---
let isRecording = false;
let recordedActions = [];
let capturedHTMLs = [];
let startURL = '';
let recordingTabId = null; // Tab currently being interacted with
let recordedWindowId = null; // Window where recording is active
let injectedTabs = new Set(); // Keep track of tabs with content script injected

// --- Helper Functions ---
// generateSeleniumScript, repr remain the same...

/**
 * Generates the Python Selenium script content.
 * - Handles CSS and XPath selectors.
 * - Adds JS click fallback.
 * - Adds screenshot command after each step.
 * - Adds time.sleep() for Pause actions.
 * - Uses 3-second pause between other steps.
 * - Ignores HTML_Capture and Switch_Tab actions.
 * @returns {string} The generated Python script.
 */
function generateSeleniumScript() {
    let scriptLines = [
        `# Generated by Selenium Recorder Chrome Extension`,
        `# WARNING: This script executes actions sequentially starting from the initial URL.`,
        `# It does not automatically handle page navigations or window/tab switching.`,
        `# Selectors might be CSS or Absolute XPath (if CSS failed). XPath is brittle.`,
        `import time`,
        `import os`,
        `from selenium import webdriver`,
        `from selenium.webdriver.common.by import By`,
        `from selenium.webdriver.support.ui import Select`,
        `from selenium.webdriver.support.ui import WebDriverWait`,
        `from selenium.webdriver.support import expected_conditions as EC`,
        `from selenium.common.exceptions import NoSuchElementException, TimeoutException, ElementClickInterceptedException`,
        ``,
        `# --- Screenshot Setup ---`,
        `SCREENSHOT_DIR = "selenium_screenshots"`,
        `if not os.path.exists(SCREENSHOT_DIR):`,
        `    os.makedirs(SCREENSHOT_DIR)`,
        ``,
        `# --- WebDriver Setup ---`,
        `driver = webdriver.Chrome()`,
        `driver.maximize_window()`,
        `wait = WebDriverWait(driver, 10)`,
        `# Store the main window handle (optional, useful for manual switching)`,
        `# main_window_handle = driver.current_window_handle`,
        ``,
        `try:`,
        `    # 1. Navigate to Start URL`,
        `    print(f'Navigating to initial URL: ${startURL}')`,
        `    driver.get('${startURL}')`,
        "    time.sleep(3)",
        `    screenshot_path = os.path.join(SCREENSHOT_DIR, f'screenshot_step_1_navigated.png')`,
        `    driver.save_screenshot(screenshot_path)`,
        `    print(f'  Screenshot saved: {screenshot_path}')`,
        ``
    ];

    let scriptStepCounter = 2;

    // Filter out non-scriptable actions
    const scriptableActions = recordedActions.filter(action =>
        action.type !== 'HTML_Capture' && action.type !== 'Switch_Tab'
    );

    scriptableActions.forEach((action, index) => {
        // Define Python variable for current step
        scriptLines.push(`    current_script_step = ${scriptStepCounter}`);

        // Handle Pause action
        if (action.type === 'Pause') {
            scriptLines.push(`    # Step ${scriptStepCounter}: Pause`);
            scriptLines.push(`    duration = ${action.duration || 1}`); // Default to 1s if duration missing
            scriptLines.push(`    print(f'Step {current_script_step}: Pausing for {duration} second(s)...')`);
            scriptLines.push(`    time.sleep(duration)`);
            scriptLines.push(`    screenshot_path = os.path.join(SCREENSHOT_DIR, f'screenshot_step_{current_script_step}_after_pause.png')`);
            scriptLines.push(`    driver.save_screenshot(screenshot_path)`);
            scriptLines.push(`    print(f'  Screenshot saved: {screenshot_path}')`);
        }
        // Handle other scriptable actions (Click, Input, Select)
        else {
            let selector = action.selector;
            let byTypeString = action.selectorType === 'XPath' ? 'By.XPATH' :
                             selector.startsWith('#') ? 'By.ID' :
                             selector.includes('[name="') ? 'By.CSS_SELECTOR' :
                             selector.startsWith('.') ? 'By.CSS_SELECTOR' :
                             selector.match(/^[a-zA-Z]+$/) ? 'By.TAG_NAME' :
                             'By.CSS_SELECTOR';

            let selectorValue = action.selectorType === 'XPath' ? selector.substring(6) :
                                byTypeString === 'By.ID' ? selector.substring(1) :
                                selector;

            scriptLines.push(`    # Step ${scriptStepCounter}: ${action.type} on element with ${action.selectorType || 'CSS'} selector '${selector}'`);

            // Assign Python variables for selector and type
            scriptLines.push(`    py_selector_value = ${repr(selectorValue)}`);
            scriptLines.push(`    py_by_type = ${byTypeString}`);

            // Add wait and action block
            scriptLines.push(`    print(f'Step {current_script_step}: Waiting for element ({py_by_type}, {py_selector_value})')`);
            scriptLines.push(`    try:`);
            scriptLines.push(`        element = wait.until(EC.presence_of_element_located((py_by_type, py_selector_value)))`);
            if (action.type === 'Click' || action.type === 'Select') {
                 scriptLines.push(`        element = wait.until(EC.element_to_be_clickable((py_by_type, py_selector_value)))`);
            }
            scriptLines.push(`        print(f'Step {current_script_step}: Found element. Performing action: ${action.type}')`);

            switch (action.type) {
                case 'Click':
                    scriptLines.push(`        try:`);
                    scriptLines.push(`            element.click()`);
                    scriptLines.push(`        except ElementClickInterceptedException:`);
                    scriptLines.push(`            print("  WARN: Element click intercepted, attempting JavaScript click.")`);
                    scriptLines.push(`            driver.execute_script("arguments[0].click();", element)`);
                    break;
                case 'Input':
                    scriptLines.push(`        py_input_value = ${repr(action.value)}`);
                    scriptLines.push(`        element.clear() # Optional: Clear field before typing`);
                    scriptLines.push(`        element.send_keys(py_input_value)`);
                    break;
                case 'Select':
                    scriptLines.push(`        py_select_value = ${repr(action.value)}`);
                    scriptLines.push(`        select = Select(element)`);
                    scriptLines.push(`        select.select_by_value(py_select_value) # Assumes selection by value`);
                    break;
            }
            // Add Screenshot Command after action
            scriptLines.push(`        screenshot_path = os.path.join(SCREENSHOT_DIR, f'screenshot_step_{current_script_step}_after_action.png')`);
            scriptLines.push(`        driver.save_screenshot(screenshot_path)`);
            scriptLines.push(`        print(f'  Screenshot saved: {screenshot_path}')`);

            scriptLines.push(`    except TimeoutException:`);
            scriptLines.push(`        print(f'Error in Step {current_script_step}: Element not found or timed out. Selector: ({py_by_type}, {py_selector_value})')`);
            scriptLines.push(`        screenshot_path = os.path.join(SCREENSHOT_DIR, f'screenshot_step_{current_script_step}_error_timeout.png')`);
            scriptLines.push(`        driver.save_screenshot(screenshot_path)`);
            scriptLines.push(`        print(f'  Error screenshot saved: {screenshot_path}')`);
            scriptLines.push(`        raise # Re-raise the exception to stop the script`);
            scriptLines.push(``); // End of outer try block
        } // End else block for non-Pause actions

        scriptLines.push("    time.sleep(3) # Pause between steps");
        scriptLines.push(``);
        scriptStepCounter++; // Increment script step counter
    });

    scriptLines.push(`    print('Script finished successfully!')`)
    scriptLines.push(``)
    scriptLines.push(`except Exception as e:`)
    scriptLines.push(`    print(f'An unexpected error occurred outside specific steps: Type={type(e).__name__}, Message={str(e)}')`)
    scriptLines.push(`    # Screenshot on unexpected error`)
    scriptLines.push(`    try:`)
    scriptLines.push(`        screenshot_path = os.path.join(SCREENSHOT_DIR, f'screenshot_unexpected_error.png')`)
    scriptLines.push(`        driver.save_screenshot(screenshot_path)`)
    scriptLines.push(`        print(f'  Error screenshot saved: {screenshot_path}')`)
    scriptLines.push(`    except Exception as screen_err:`)
    scriptLines.push(`        print(f"  Could not save error screenshot: {str(screen_err)}")`)
    scriptLines.push(``)
    scriptLines.push(`finally:`)
    scriptLines.push(`    # --- Cleanup ---`)
    scriptLines.push(`    print('Closing WebDriver.')`)
    scriptLines.push(`    driver.quit()`)
    scriptLines.push(``)

    return scriptLines.join('\n');
}

/**
 * Helper function to mimic Python's repr() for safely embedding strings in the generated script.
 * @param {*} value - The value to represent.
 * @returns {string} A string representation suitable for embedding in Python code.
 */
function repr(value) {
    return JSON.stringify(String(value));
}


/**
 * Resets the recording state. Does NOT disable the side panel.
 */
function resetRecordingState() {
    isRecording = false;
    recordedActions = [];
    capturedHTMLs = [];
    startURL = '';
    recordingTabId = null;
    recordedWindowId = null;
    injectedTabs.clear(); // Clear the set of injected tabs
    console.log("Background: Recording state reset.");

    // Update side panel UI if it's still open
    chrome.runtime.sendMessage({ command: "update_ui", data: { actions: [], isRecording: false, htmlCount: 0 } })
        .catch(e => console.log("Background: Side panel likely closed during reset (expected)."));
}

/**
 * Injects the content script into a given tab if not already injected.
 * @param {number} tabId - The ID of the tab to inject into.
 */
async function ensureContentScriptInjected(tabId) {
    if (!tabId || injectedTabs.has(tabId)) {
        // console.log(`Background: Skipping injection for tab ${tabId} (already injected or invalid)`);
        return; // Already injected or invalid tab ID
    }
    console.log(`Background: Attempting to inject content script into tab ${tabId}`);
    try {
        // Check if tab exists and is accessible first
        const tab = await chrome.tabs.get(tabId);
        if (!tab || tab.url?.startsWith('chrome://') || tab.url?.startsWith('about:')) {
            console.warn(`Background: Cannot inject script into inaccessible tab ${tabId} (URL: ${tab?.url})`);
            return;
        }

        await chrome.scripting.executeScript({
            target: { tabId: tabId },
            files: ['content.js']
        });
        console.log(`Background: Content script injected successfully into tab ${tabId}.`);
        injectedTabs.add(tabId); // Mark as injected
    } catch (err) {
        console.error(`Background: Failed to inject content script into tab ${tabId}:`, err);
        // Don't add to injectedTabs if it failed
    }
}


// --- Event Listeners ---

chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
    console.log("Background received message:", message.command, "from", sender.tab ? `tab ${sender.tab.id} in window ${sender.tab.windowId}` : "extension");

    switch (message.command) {
        case "start_recording":
            if (isRecording) {
                console.warn("Background: Recording already in progress.");
                sendResponse({ success: false, message: "Recording already active." });
                return true;
            }

            const { tabId, windowId, url } = message.data || {};
            if (!tabId || !windowId || !url) {
                 console.error("Background: Missing tabId, windowId, or url in start_recording message.");
                 sendResponse({ success: false, message: "Missing data from popup." });
                 return true;
            }

            resetRecordingState(); // Ensure clean state

            recordingTabId = tabId;
            recordedWindowId = windowId;
            startURL = url;
            isRecording = true;

            console.log(`Background: Starting recording state for tab ${recordingTabId} in window ${recordedWindowId} with URL: ${startURL}`);

            // Inject into the initial tab
            ensureContentScriptInjected(recordingTabId)
                .then(() => new Promise(resolve => setTimeout(resolve, 250))) // Wait after injection attempt
                .then(() => {
                    console.log("Background: Sending initial UI update to side panel.");
                    return chrome.runtime.sendMessage({
                        command: "update_ui",
                        data: { actions: recordedActions, isRecording: true, startUrl: startURL, htmlCount: capturedHTMLs.length }
                    });
                })
                .then(() => {
                    console.log("Background: Initial UI update sent successfully.");
                    sendResponse({ success: true });
                })
                .catch(error => {
                    console.error("Background: Error during recording start sequence:", error);
                    resetRecordingState(); // Clean up fully on error
                    sendResponse({ success: false, message: `Failed to start recording logic: ${error.message}` });
                });

            return true; // Indicate async response

        case "record_action":
            // *** Check if the action comes from the currently targeted tab and window ***
            if (!isRecording || !recordingTabId || !sender.tab || sender.tab.id !== recordingTabId || sender.tab.windowId !== recordedWindowId) {
                console.warn(`Background: Ignoring action from non-recorded tab/window. Expected: T${recordingTabId}/W${recordedWindowId}, Got: T${sender.tab?.id}/W${sender.tab?.windowId}`);
                return true; // Ignore but acknowledge
            }
            const action = message.data;
            action.step = recordedActions.length + 1;

            if (action.selector && action.selector.startsWith('xpath=')) {
                action.selectorType = 'XPath';
            } else {
                action.selectorType = 'CSS';
            }

            if (!action.selector) {
                 action.selector = "SELECTOR_MISSING";
                 action.selectorType = 'N/A';
            }
            delete action.elementInfo;

            console.log("Background: Recording action:", action);
            recordedActions.push(action);

            chrome.runtime.sendMessage({ command: "update_ui", data: { actions: recordedActions, isRecording: true, htmlCount: capturedHTMLs.length } })
                .catch(e => console.warn("Background: Side panel not available for action update:", e));

            sendResponse({ success: true });
            return true;

        case "capture_html":
             if (!isRecording || !recordingTabId) {
                sendResponse({ success: false, message: "Not recording." });
                return true;
             }
             // Send message to the *currently targeted* recording tab
             chrome.tabs.sendMessage(recordingTabId, { command: "get_html" }, (response) => {
                 if (chrome.runtime.lastError) {
                     console.error(`Background: Error requesting HTML from tab ${recordingTabId}:`, chrome.runtime.lastError.message);
                     sendResponse({ success: false, message: chrome.runtime.lastError.message });
                 } else if (response && response.success && typeof response.html === 'string') {
                     capturedHTMLs.push(response.html);
                     console.log(`Background: HTML captured (${capturedHTMLs.length} total). Size: ${response.html.length}`);

                     const captureAction = {
                         type: 'HTML_Capture',
                         step: recordedActions.length + 1,
                         timestamp: Date.now(),
                         selectorType: 'N/A'
                     };
                     recordedActions.push(captureAction);
                     console.log("Background: Recording action:", captureAction);

                     chrome.runtime.sendMessage({
                         command: "update_ui",
                         data: {
                             actions: recordedActions,
                             htmlCount: capturedHTMLs.length,
                             isRecording: true
                         }
                      })
                         .catch(e => console.warn("Background: Side panel not available for HTML count update:", e));

                     sendResponse({ success: true, count: capturedHTMLs.length });
                 } else {
                     console.error("Background: Failed to get valid HTML from content script.", response);
                     sendResponse({ success: false, message: "Failed to get valid HTML." });
                 }
             }).catch(error => {
                  console.error(`Background: Error sending get_html message to tab ${recordingTabId}:`, error);
                  sendResponse({ success: false, message: `Error contacting tab: ${error.message}` });
             });
             return true;

        case "delete_action":
             if (!isRecording) {
                sendResponse({ success: false, message: "Not recording." });
                return true;
             }
             const stepToDelete = message.data?.step;
             if (typeof stepToDelete !== 'number') {
                 console.error("Background: Invalid step number received for deletion.");
                 sendResponse({ success: false, message: "Invalid step number." });
                 return true;
             }

             console.log(`Background: Attempting to delete action at step ${stepToDelete}`);
             const indexToDelete = recordedActions.findIndex(action => action.step === stepToDelete);

             if (indexToDelete === -1) {
                 console.warn(`Background: Action with step ${stepToDelete} not found.`);
                 sendResponse({ success: false, message: "Step not found." });
                 return true;
             }

             const deletedAction = recordedActions.splice(indexToDelete, 1)[0];
             console.log("Background: Deleted action:", deletedAction);

             // Don't delete HTML blob for safety
             if (deletedAction.type === 'HTML_Capture') {
                  console.warn("Background: HTML blob deletion on action delete is disabled for safety.");
             }

             // Re-number subsequent steps
             for (let i = indexToDelete; i < recordedActions.length; i++) {
                 recordedActions[i].step = i + 1;
             }
             console.log("Background: Renumbered subsequent steps.");

             chrome.runtime.sendMessage({
                 command: "update_ui",
                 data: {
                     actions: recordedActions,
                     htmlCount: capturedHTMLs.length,
                     isRecording: true
                 }
              })
                 .catch(e => console.warn("Background: Side panel not available for delete update:", e));

             sendResponse({ success: true });
             return true;

        case "add_pause":
            if (!isRecording) {
                sendResponse({ success: false, message: "Not recording." });
                return true;
            }
            const duration = message.data?.duration;
            if (typeof duration !== 'number' || duration <= 0) {
                 console.error("Background: Invalid pause duration received.");
                 sendResponse({ success: false, message: "Invalid duration." });
                 return true;
            }

            const pauseAction = {
                type: 'Pause',
                duration: duration,
                step: recordedActions.length + 1,
                timestamp: Date.now(),
                selectorType: 'N/A'
            };
            console.log("Background: Recording action:", pauseAction);
            recordedActions.push(pauseAction);

            chrome.runtime.sendMessage({
                command: "update_ui",
                data: {
                    actions: recordedActions,
                    htmlCount: capturedHTMLs.length,
                    isRecording: true
                }
             })
                .catch(e => console.warn("Background: Side panel not available for pause update:", e));

            sendResponse({ success: true });
            return true;


        case "save_export":
            if (!isRecording) {
                sendResponse({ success: false, message: "Not recording." });
                return true;
            }
            console.log("Background: Save and Export triggered.");

            if (typeof JSZip === 'undefined') {
                 console.error("Background: JSZip is not defined. Export failed.");
                 sendResponse({ success: false, message: "JSZip library error (not loaded)." });
                 return true;
            }

            const seleniumScript = generateSeleniumScript();
            console.log("Background: Selenium script generated.");

            try {
                const zip = new JSZip();
                zip.file("selenium_script.py", seleniumScript);

                console.log(`Background: Preparing to zip ${capturedHTMLs.length} captured HTML file(s).`);
                // console.log('Background: capturedHTMLs array content (lengths):', capturedHTMLs.map(h => h?.length ?? 'null')); // Optional debug

                capturedHTMLs.forEach((html, index) => {
                    const filename = `capture_${index + 1}.html`;
                    // console.log(`Background: Adding file to zip: ${filename}, HTML size: ${html?.length ?? 'N/A'}`); // Optional debug
                    if (typeof html === 'string') {
                         zip.file(filename, html);
                    } else {
                         console.warn(`Background: Skipping invalid HTML data at index ${index}`);
                    }
                });

                console.log("Background: Generating ZIP blob...");
                zip.generateAsync({ type: "blob" })
                    .then(content => {
                        console.log(`Background: ZIP blob generated (size: ${content.size}). Converting to data URL...`);
                        const reader = new FileReader();
                        reader.onload = function() {
                            const dataUrl = reader.result;
                            const zipFilename = "selenium_recording.zip";
                            console.log(`Background: Blob converted to data URL. Initiating download...`);

                            chrome.downloads.download({
                                url: dataUrl,
                                filename: zipFilename,
                                saveAs: true
                            }).then(downloadId => {
                                 if (downloadId) {
                                     console.log("Background: Download started with ID:", downloadId);
                                     sendResponse({ success: true });
                                     resetRecordingState(); // Reset state, panel stays open
                                 } else {
                                     console.error("Background: Download failed to initiate.");
                                     sendResponse({ success: false, message: "Download failed to initiate." });
                                     resetRecordingState();
                                 }
                            }).catch(err => {
                                 console.error("Background: Download failed:", err);
                                 sendResponse({ success: false, message: `Download failed: ${err.message}` });
                                 resetRecordingState();
                            });
                        };
                        reader.onerror = function() {
                            console.error("Background: FileReader failed to read blob.");
                            sendResponse({ success: false, message: "Failed to read generated ZIP data." });
                            resetRecordingState();
                        };
                        reader.readAsDataURL(content);
                    })
                    .catch(err => {
                        console.error("Background: Error generating ZIP blob:", err);
                        sendResponse({ success: false, message: `ZIP generation failed: ${err.message}` });
                        resetRecordingState();
                    });

            } catch (e) {
                console.error("Background: Error during ZIP creation/processing:", e);
                sendResponse({ success: false, message: `JSZip library error: ${e.message}` });
                resetRecordingState();
            }
            return true;

        case "cancel_recording":
            if (!isRecording) {
                sendResponse({ success: false, message: "Not recording." });
                return true;
            }
            console.log("Background: Cancel recording request received.");
            resetRecordingState(); // Reset state, panel stays open
            // We could try to close the panel programmatically if needed:
            // if (recordedWindowId) { chrome.sidePanel.setOptions({ windowId: recordedWindowId, enabled: false }); }
            sendResponse({ success: true });
            return true;


        case "get_status":
            sendResponse({ isRecording: isRecording, recordingWindowId: recordedWindowId });
            return true;

        case "request_current_state":
             if (isRecording && sender.contextType === "SIDE_PANEL") {
                 console.log("Background: Side panel requested current state.");
                 sendResponse({
                     actions: recordedActions,
                     htmlCount: capturedHTMLs.length,
                     isRecording: true,
                     startUrl: startURL
                 });
             } else {
                 sendResponse(null);
             }
             return true;


        case "stop_recording_internal":
            if (isRecording && sender.contextType === "SIDE_PANEL") {
                 console.log("Background: Side panel context destroyed, stopping recording.");
                 resetRecordingState(); // Reset state only
                 sendResponse({success: true});
            }
             else {
                 sendResponse({success: false, message: "Not recording or invalid context"});
             }
            return true;


        default:
             console.log("Background: Unhandled command:", message.command);
             sendResponse({ success: false, message: "Unknown command" });
             return false;
    }
});

// Tab listeners
chrome.tabs.onRemoved.addListener((tabId, removeInfo) => {
    // Stop recording if the recorded tab itself is closed
    if (isRecording && tabId === recordingTabId) {
        console.log(`Background: Recorded tab (${tabId}) was closed. Stopping recording.`);
        resetRecordingState();
    }
    // Stop recording if the window containing the recording is closed
    if (isRecording && removeInfo.windowId === recordedWindowId && removeInfo.isWindowClosing) {
        console.log(`Background: Recorded window (${recordedWindowId}) closed. Stopping recording.`);
        resetRecordingState();
    }
});

// *** Add listener for manual tab activation ***
chrome.tabs.onActivated.addListener(async (activeInfo) => {
    // Check if recording is active and the activation is within the recorded window
    if (isRecording && recordedWindowId && activeInfo.windowId === recordedWindowId) {
        const newTabId = activeInfo.tabId;
        // Check if it's a switch to a *different* tab than the one we were last recording
        if (newTabId !== recordingTabId) {
            console.log(`Background: Tab activated: ${newTabId} in recorded window ${recordedWindowId}. Switching target.`);

             // 1. Record Switch Tab action
             const switchAction = {
                type: 'Switch_Tab',
                tabId: newTabId,
                // url: await getTabUrl(newTabId), // Getting URL here might be async, skip for simplicity
                step: recordedActions.length + 1,
                timestamp: Date.now(),
                selectorType: 'N/A'
            };
            recordedActions.push(switchAction);
            console.log("Background: Recording action:", switchAction);

            // 2. Update recording target
            recordingTabId = newTabId;

            // 3. Ensure content script is injected into the newly activated tab
            await ensureContentScriptInjected(newTabId);

            // 4. Update the side panel UI
            chrome.runtime.sendMessage({
                command: "update_ui",
                data: {
                    actions: recordedActions,
                    isRecording: true,
                    htmlCount: capturedHTMLs.length,
                }
             })
                .catch(e => console.warn("Background: Side panel not available for tab activation update:", e));
        }
    }
});


// Detect popups/new tabs opened from the recorded tab within the same window context
chrome.tabs.onCreated.addListener((tab) => {
    // Check if recording, if the new tab has an opener, and if it's in the recorded window
    if (isRecording && tab.openerTabId === recordingTabId && tab.windowId === recordedWindowId && tab.id) {
        const newTabId = tab.id;
        console.log(`Background: New tab (${newTabId}) opened by recorded tab (${recordingTabId}) in same window. URL: ${tab.pendingUrl || tab.url}`);

        // 1. Record Switch Tab action
        const switchAction = {
            type: 'Switch_Tab',
            tabId: newTabId,
            url: tab.pendingUrl || tab.url,
            step: recordedActions.length + 1,
            timestamp: Date.now(),
            selectorType: 'N/A'
        };
        recordedActions.push(switchAction);
        console.log("Background: Recording action:", switchAction);

        // 2. Update recording target
        console.log(`Background: Switching recording target from tab ${recordingTabId} to ${newTabId}`);
        recordingTabId = newTabId;

        // 3. Inject content script when new tab finishes loading
        const listener = function(updatedTabId, changeInfo, updatedTab) {
            if (updatedTabId === newTabId && changeInfo.status === 'complete') {
                chrome.tabs.onUpdated.removeListener(listener); // Clean up listener

                if (!isRecording || recordingTabId !== newTabId) {
                     console.log(`Background: Recording stopped/changed before tab ${newTabId} finished. Skipping injection.`);
                     return;
                }
                ensureContentScriptInjected(newTabId); // Use helper function
            }
        };
        chrome.tabs.onUpdated.addListener(listener);

        // 4. Update side panel UI
        chrome.runtime.sendMessage({
            command: "update_ui",
            data: {
                actions: recordedActions,
                isRecording: true,
                htmlCount: capturedHTMLs.length,
            }
         })
            .catch(e => console.warn("Background: Side panel not available for tab switch update:", e));

    }
});


// Listener for same-tab updates (reloads, navigations)
chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {
    // Only log if it's the currently recorded tab
    if (isRecording && tabId === recordingTabId) {
        if (changeInfo.url) {
             console.log(`Background: Recorded tab (${tabId}) navigated to ${changeInfo.url}. Recording continues.`);
        }
        if (changeInfo.status === 'loading') {
             console.log(`Background: Recorded tab (${tabId}) status changed to loading. Recording continues.`);
        }
    }
});


console.log("Background service worker started.");
